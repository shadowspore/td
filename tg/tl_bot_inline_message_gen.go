// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// BotInlineMessageMediaAuto represents TL type `botInlineMessageMediaAuto#764cf810`.
// Send whatever media is attached to the botInlineMediaResult¹
//
// Links:
//  1) https://core.telegram.org/constructor/botInlineMediaResult
//
// See https://core.telegram.org/constructor/botInlineMessageMediaAuto for reference.
type BotInlineMessageMediaAuto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Caption
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaAutoTypeID is TL type id of BotInlineMessageMediaAuto.
const BotInlineMessageMediaAutoTypeID = 0x764cf810

func (b *BotInlineMessageMediaAuto) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.Message == "") {
		return false
	}
	if !(b.Entities == nil) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaAuto) String() string {
	if b == nil {
		return "BotInlineMessageMediaAuto(nil)"
	}
	type Alias BotInlineMessageMediaAuto
	return fmt.Sprintf("BotInlineMessageMediaAuto%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaAuto from given interface.
func (b *BotInlineMessageMediaAuto) FillFrom(from interface {
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		b.Entities = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaAuto) TypeID() uint32 {
	return BotInlineMessageMediaAutoTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaAuto) TypeName() string {
	return "botInlineMessageMediaAuto"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaAuto) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaAuto",
		ID:   BotInlineMessageMediaAutoTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaAuto) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaAuto#764cf810 as nil")
	}
	buf.PutID(BotInlineMessageMediaAutoTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaAuto) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaAuto#764cf810 as nil")
	}
	if !(b.Entities == nil) {
		b.Flags.Set(1)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field flags: %w", err)
	}
	buf.PutString(b.Message)
	if b.Flags.Has(1) {
		buf.PutVectorHeader(len(b.Entities))
		for idx, v := range b.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(buf); err != nil {
				return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaAuto#764cf810: field reply_markup: %w", err)
		}
	}
	return nil
}

// GetMessage returns value of Message field.
func (b *BotInlineMessageMediaAuto) GetMessage() (value string) {
	return b.Message
}

// SetEntities sets value of Entities conditional field.
func (b *BotInlineMessageMediaAuto) SetEntities(value []MessageEntityClass) {
	b.Flags.Set(1)
	b.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaAuto) GetEntities() (value []MessageEntityClass, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return b.Entities, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (b *BotInlineMessageMediaAuto) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(b.Entities), true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaAuto) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaAuto) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaAuto) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaAuto#764cf810 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaAutoTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaAuto) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaAuto#764cf810 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field flags: %w", err)
		}
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field message: %w", err)
		}
		b.Message = value
	}
	if b.Flags.Has(1) {
		headerLen, err := buf.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(buf)
			if err != nil {
				return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field entities: %w", err)
			}
			b.Entities = append(b.Entities, value)
		}
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaAuto#764cf810: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaAuto) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaAuto.
var (
	_ bin.Encoder     = &BotInlineMessageMediaAuto{}
	_ bin.Decoder     = &BotInlineMessageMediaAuto{}
	_ bin.BareEncoder = &BotInlineMessageMediaAuto{}
	_ bin.BareDecoder = &BotInlineMessageMediaAuto{}

	_ BotInlineMessageClass = &BotInlineMessageMediaAuto{}
)

// BotInlineMessageText represents TL type `botInlineMessageText#8c7f65e2`.
// Send a simple text message
//
// See https://core.telegram.org/constructor/botInlineMessageText for reference.
type BotInlineMessageText struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Disable webpage preview
	NoWebpage bool
	// The message
	Message string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetEntities and GetEntities helpers.
	Entities []MessageEntityClass
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageTextTypeID is TL type id of BotInlineMessageText.
const BotInlineMessageTextTypeID = 0x8c7f65e2

func (b *BotInlineMessageText) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.NoWebpage == false) {
		return false
	}
	if !(b.Message == "") {
		return false
	}
	if !(b.Entities == nil) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageText) String() string {
	if b == nil {
		return "BotInlineMessageText(nil)"
	}
	type Alias BotInlineMessageText
	return fmt.Sprintf("BotInlineMessageText%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageText from given interface.
func (b *BotInlineMessageText) FillFrom(from interface {
	GetNoWebpage() (value bool)
	GetMessage() (value string)
	GetEntities() (value []MessageEntityClass, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.NoWebpage = from.GetNoWebpage()
	b.Message = from.GetMessage()
	if val, ok := from.GetEntities(); ok {
		b.Entities = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageText) TypeID() uint32 {
	return BotInlineMessageTextTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageText) TypeName() string {
	return "botInlineMessageText"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageText) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageText",
		ID:   BotInlineMessageTextTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "NoWebpage",
			SchemaName: "no_webpage",
			Null:       !b.Flags.Has(0),
		},
		{
			Name:       "Message",
			SchemaName: "message",
		},
		{
			Name:       "Entities",
			SchemaName: "entities",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageText) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageText#8c7f65e2 as nil")
	}
	buf.PutID(BotInlineMessageTextTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageText) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageText#8c7f65e2 as nil")
	}
	if !(b.NoWebpage == false) {
		b.Flags.Set(0)
	}
	if !(b.Entities == nil) {
		b.Flags.Set(1)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field flags: %w", err)
	}
	buf.PutString(b.Message)
	if b.Flags.Has(1) {
		buf.PutVectorHeader(len(b.Entities))
		for idx, v := range b.Entities {
			if v == nil {
				return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field entities element with index %d is nil", idx)
			}
			if err := v.Encode(buf); err != nil {
				return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field entities element with index %d: %w", idx, err)
			}
		}
	}
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageText#8c7f65e2: field reply_markup: %w", err)
		}
	}
	return nil
}

// SetNoWebpage sets value of NoWebpage conditional field.
func (b *BotInlineMessageText) SetNoWebpage(value bool) {
	if value {
		b.Flags.Set(0)
		b.NoWebpage = true
	} else {
		b.Flags.Unset(0)
		b.NoWebpage = false
	}
}

// GetNoWebpage returns value of NoWebpage conditional field.
func (b *BotInlineMessageText) GetNoWebpage() (value bool) {
	return b.Flags.Has(0)
}

// GetMessage returns value of Message field.
func (b *BotInlineMessageText) GetMessage() (value string) {
	return b.Message
}

// SetEntities sets value of Entities conditional field.
func (b *BotInlineMessageText) SetEntities(value []MessageEntityClass) {
	b.Flags.Set(1)
	b.Entities = value
}

// GetEntities returns value of Entities conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageText) GetEntities() (value []MessageEntityClass, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return b.Entities, true
}

// MapEntities returns field Entities wrapped in MessageEntityClassArray helper.
func (b *BotInlineMessageText) MapEntities() (value MessageEntityClassArray, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return MessageEntityClassArray(b.Entities), true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageText) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageText) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageText) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageText#8c7f65e2 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageTextTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageText) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageText#8c7f65e2 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field flags: %w", err)
		}
	}
	b.NoWebpage = b.Flags.Has(0)
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field message: %w", err)
		}
		b.Message = value
	}
	if b.Flags.Has(1) {
		headerLen, err := buf.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(buf)
			if err != nil {
				return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field entities: %w", err)
			}
			b.Entities = append(b.Entities, value)
		}
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageText#8c7f65e2: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageText) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageText.
var (
	_ bin.Encoder     = &BotInlineMessageText{}
	_ bin.Decoder     = &BotInlineMessageText{}
	_ bin.BareEncoder = &BotInlineMessageText{}
	_ bin.BareDecoder = &BotInlineMessageText{}

	_ BotInlineMessageClass = &BotInlineMessageText{}
)

// BotInlineMessageMediaGeo represents TL type `botInlineMessageMediaGeo#51846fd`.
// Send a geolocation
//
// See https://core.telegram.org/constructor/botInlineMessageMediaGeo for reference.
type BotInlineMessageMediaGeo struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation
	Geo GeoPointClass
	// For live locations¹, a direction in which the location moves, in degrees; 1-360.
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Validity period
	//
	// Use SetPeriod and GetPeriod helpers.
	Period int
	// For live locations¹, a maximum distance to another chat member for proximity alerts,
	// in meters (0-100000).
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaGeoTypeID is TL type id of BotInlineMessageMediaGeo.
const BotInlineMessageMediaGeoTypeID = 0x51846fd

func (b *BotInlineMessageMediaGeo) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.Geo == nil) {
		return false
	}
	if !(b.Heading == 0) {
		return false
	}
	if !(b.Period == 0) {
		return false
	}
	if !(b.ProximityNotificationRadius == 0) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaGeo) String() string {
	if b == nil {
		return "BotInlineMessageMediaGeo(nil)"
	}
	type Alias BotInlineMessageMediaGeo
	return fmt.Sprintf("BotInlineMessageMediaGeo%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaGeo from given interface.
func (b *BotInlineMessageMediaGeo) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetHeading() (value int, ok bool)
	GetPeriod() (value int, ok bool)
	GetProximityNotificationRadius() (value int, ok bool)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.Geo = from.GetGeo()
	if val, ok := from.GetHeading(); ok {
		b.Heading = val
	}

	if val, ok := from.GetPeriod(); ok {
		b.Period = val
	}

	if val, ok := from.GetProximityNotificationRadius(); ok {
		b.ProximityNotificationRadius = val
	}

	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaGeo) TypeID() uint32 {
	return BotInlineMessageMediaGeoTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaGeo) TypeName() string {
	return "botInlineMessageMediaGeo"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaGeo) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaGeo",
		ID:   BotInlineMessageMediaGeoTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Heading",
			SchemaName: "heading",
			Null:       !b.Flags.Has(0),
		},
		{
			Name:       "Period",
			SchemaName: "period",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "ProximityNotificationRadius",
			SchemaName: "proximity_notification_radius",
			Null:       !b.Flags.Has(3),
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaGeo) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaGeo#51846fd as nil")
	}
	buf.PutID(BotInlineMessageMediaGeoTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaGeo) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaGeo#51846fd as nil")
	}
	if !(b.Heading == 0) {
		b.Flags.Set(0)
	}
	if !(b.Period == 0) {
		b.Flags.Set(1)
	}
	if !(b.ProximityNotificationRadius == 0) {
		b.Flags.Set(3)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field flags: %w", err)
	}
	if b.Geo == nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field geo is nil")
	}
	if err := b.Geo.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field geo: %w", err)
	}
	if b.Flags.Has(0) {
		buf.PutInt(b.Heading)
	}
	if b.Flags.Has(1) {
		buf.PutInt(b.Period)
	}
	if b.Flags.Has(3) {
		buf.PutInt(b.ProximityNotificationRadius)
	}
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaGeo#51846fd: field reply_markup: %w", err)
		}
	}
	return nil
}

// GetGeo returns value of Geo field.
func (b *BotInlineMessageMediaGeo) GetGeo() (value GeoPointClass) {
	return b.Geo
}

// SetHeading sets value of Heading conditional field.
func (b *BotInlineMessageMediaGeo) SetHeading(value int) {
	b.Flags.Set(0)
	b.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetHeading() (value int, ok bool) {
	if !b.Flags.Has(0) {
		return value, false
	}
	return b.Heading, true
}

// SetPeriod sets value of Period conditional field.
func (b *BotInlineMessageMediaGeo) SetPeriod(value int) {
	b.Flags.Set(1)
	b.Period = value
}

// GetPeriod returns value of Period conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetPeriod() (value int, ok bool) {
	if !b.Flags.Has(1) {
		return value, false
	}
	return b.Period, true
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (b *BotInlineMessageMediaGeo) SetProximityNotificationRadius(value int) {
	b.Flags.Set(3)
	b.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetProximityNotificationRadius() (value int, ok bool) {
	if !b.Flags.Has(3) {
		return value, false
	}
	return b.ProximityNotificationRadius, true
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaGeo) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaGeo) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaGeo) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaGeo#51846fd to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaGeoTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaGeo) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaGeo#51846fd to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field flags: %w", err)
		}
	}
	{
		value, err := DecodeGeoPoint(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field geo: %w", err)
		}
		b.Geo = value
	}
	if b.Flags.Has(0) {
		value, err := buf.Int()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field heading: %w", err)
		}
		b.Heading = value
	}
	if b.Flags.Has(1) {
		value, err := buf.Int()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field period: %w", err)
		}
		b.Period = value
	}
	if b.Flags.Has(3) {
		value, err := buf.Int()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field proximity_notification_radius: %w", err)
		}
		b.ProximityNotificationRadius = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaGeo#51846fd: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaGeo) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaGeo.
var (
	_ bin.Encoder     = &BotInlineMessageMediaGeo{}
	_ bin.Decoder     = &BotInlineMessageMediaGeo{}
	_ bin.BareEncoder = &BotInlineMessageMediaGeo{}
	_ bin.BareDecoder = &BotInlineMessageMediaGeo{}

	_ BotInlineMessageClass = &BotInlineMessageMediaGeo{}
)

// BotInlineMessageMediaVenue represents TL type `botInlineMessageMediaVenue#8a86659c`.
// Send a venue
//
// See https://core.telegram.org/constructor/botInlineMessageMediaVenue for reference.
type BotInlineMessageMediaVenue struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Geolocation of venue
	Geo GeoPointClass
	// Venue name
	Title string
	// Address
	Address string
	// Venue provider: currently only "foursquare" needs to be supported
	Provider string
	// Venue ID in the provider's database
	VenueID string
	// Venue type in the provider's database
	VenueType string
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaVenueTypeID is TL type id of BotInlineMessageMediaVenue.
const BotInlineMessageMediaVenueTypeID = 0x8a86659c

func (b *BotInlineMessageMediaVenue) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.Geo == nil) {
		return false
	}
	if !(b.Title == "") {
		return false
	}
	if !(b.Address == "") {
		return false
	}
	if !(b.Provider == "") {
		return false
	}
	if !(b.VenueID == "") {
		return false
	}
	if !(b.VenueType == "") {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaVenue) String() string {
	if b == nil {
		return "BotInlineMessageMediaVenue(nil)"
	}
	type Alias BotInlineMessageMediaVenue
	return fmt.Sprintf("BotInlineMessageMediaVenue%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaVenue from given interface.
func (b *BotInlineMessageMediaVenue) FillFrom(from interface {
	GetGeo() (value GeoPointClass)
	GetTitle() (value string)
	GetAddress() (value string)
	GetProvider() (value string)
	GetVenueID() (value string)
	GetVenueType() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.Geo = from.GetGeo()
	b.Title = from.GetTitle()
	b.Address = from.GetAddress()
	b.Provider = from.GetProvider()
	b.VenueID = from.GetVenueID()
	b.VenueType = from.GetVenueType()
	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaVenue) TypeID() uint32 {
	return BotInlineMessageMediaVenueTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaVenue) TypeName() string {
	return "botInlineMessageMediaVenue"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaVenue) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaVenue",
		ID:   BotInlineMessageMediaVenueTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Geo",
			SchemaName: "geo",
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Address",
			SchemaName: "address",
		},
		{
			Name:       "Provider",
			SchemaName: "provider",
		},
		{
			Name:       "VenueID",
			SchemaName: "venue_id",
		},
		{
			Name:       "VenueType",
			SchemaName: "venue_type",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaVenue) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaVenue#8a86659c as nil")
	}
	buf.PutID(BotInlineMessageMediaVenueTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaVenue) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaVenue#8a86659c as nil")
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field flags: %w", err)
	}
	if b.Geo == nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field geo is nil")
	}
	if err := b.Geo.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field geo: %w", err)
	}
	buf.PutString(b.Title)
	buf.PutString(b.Address)
	buf.PutString(b.Provider)
	buf.PutString(b.VenueID)
	buf.PutString(b.VenueType)
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaVenue#8a86659c: field reply_markup: %w", err)
		}
	}
	return nil
}

// GetGeo returns value of Geo field.
func (b *BotInlineMessageMediaVenue) GetGeo() (value GeoPointClass) {
	return b.Geo
}

// GetTitle returns value of Title field.
func (b *BotInlineMessageMediaVenue) GetTitle() (value string) {
	return b.Title
}

// GetAddress returns value of Address field.
func (b *BotInlineMessageMediaVenue) GetAddress() (value string) {
	return b.Address
}

// GetProvider returns value of Provider field.
func (b *BotInlineMessageMediaVenue) GetProvider() (value string) {
	return b.Provider
}

// GetVenueID returns value of VenueID field.
func (b *BotInlineMessageMediaVenue) GetVenueID() (value string) {
	return b.VenueID
}

// GetVenueType returns value of VenueType field.
func (b *BotInlineMessageMediaVenue) GetVenueType() (value string) {
	return b.VenueType
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaVenue) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaVenue) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaVenue) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaVenue#8a86659c to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaVenue) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaVenue#8a86659c to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field flags: %w", err)
		}
	}
	{
		value, err := DecodeGeoPoint(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field geo: %w", err)
		}
		b.Geo = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field title: %w", err)
		}
		b.Title = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field address: %w", err)
		}
		b.Address = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field provider: %w", err)
		}
		b.Provider = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field venue_id: %w", err)
		}
		b.VenueID = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field venue_type: %w", err)
		}
		b.VenueType = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaVenue#8a86659c: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaVenue) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaVenue.
var (
	_ bin.Encoder     = &BotInlineMessageMediaVenue{}
	_ bin.Decoder     = &BotInlineMessageMediaVenue{}
	_ bin.BareEncoder = &BotInlineMessageMediaVenue{}
	_ bin.BareDecoder = &BotInlineMessageMediaVenue{}

	_ BotInlineMessageClass = &BotInlineMessageMediaVenue{}
)

// BotInlineMessageMediaContact represents TL type `botInlineMessageMediaContact#18d1cdc2`.
// Send a contact
//
// See https://core.telegram.org/constructor/botInlineMessageMediaContact for reference.
type BotInlineMessageMediaContact struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Phone number
	PhoneNumber string
	// First name
	FirstName string
	// Last name
	LastName string
	// VCard info
	Vcard string
	// Inline keyboard
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaContactTypeID is TL type id of BotInlineMessageMediaContact.
const BotInlineMessageMediaContactTypeID = 0x18d1cdc2

func (b *BotInlineMessageMediaContact) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.PhoneNumber == "") {
		return false
	}
	if !(b.FirstName == "") {
		return false
	}
	if !(b.LastName == "") {
		return false
	}
	if !(b.Vcard == "") {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaContact) String() string {
	if b == nil {
		return "BotInlineMessageMediaContact(nil)"
	}
	type Alias BotInlineMessageMediaContact
	return fmt.Sprintf("BotInlineMessageMediaContact%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaContact from given interface.
func (b *BotInlineMessageMediaContact) FillFrom(from interface {
	GetPhoneNumber() (value string)
	GetFirstName() (value string)
	GetLastName() (value string)
	GetVcard() (value string)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.PhoneNumber = from.GetPhoneNumber()
	b.FirstName = from.GetFirstName()
	b.LastName = from.GetLastName()
	b.Vcard = from.GetVcard()
	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaContact) TypeID() uint32 {
	return BotInlineMessageMediaContactTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaContact) TypeName() string {
	return "botInlineMessageMediaContact"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaContact) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaContact",
		ID:   BotInlineMessageMediaContactTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "PhoneNumber",
			SchemaName: "phone_number",
		},
		{
			Name:       "FirstName",
			SchemaName: "first_name",
		},
		{
			Name:       "LastName",
			SchemaName: "last_name",
		},
		{
			Name:       "Vcard",
			SchemaName: "vcard",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaContact) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaContact#18d1cdc2 as nil")
	}
	buf.PutID(BotInlineMessageMediaContactTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaContact) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaContact#18d1cdc2 as nil")
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaContact#18d1cdc2: field flags: %w", err)
	}
	buf.PutString(b.PhoneNumber)
	buf.PutString(b.FirstName)
	buf.PutString(b.LastName)
	buf.PutString(b.Vcard)
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaContact#18d1cdc2: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaContact#18d1cdc2: field reply_markup: %w", err)
		}
	}
	return nil
}

// GetPhoneNumber returns value of PhoneNumber field.
func (b *BotInlineMessageMediaContact) GetPhoneNumber() (value string) {
	return b.PhoneNumber
}

// GetFirstName returns value of FirstName field.
func (b *BotInlineMessageMediaContact) GetFirstName() (value string) {
	return b.FirstName
}

// GetLastName returns value of LastName field.
func (b *BotInlineMessageMediaContact) GetLastName() (value string) {
	return b.LastName
}

// GetVcard returns value of Vcard field.
func (b *BotInlineMessageMediaContact) GetVcard() (value string) {
	return b.Vcard
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaContact) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaContact) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaContact) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaContact#18d1cdc2 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaContact) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaContact#18d1cdc2 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field flags: %w", err)
		}
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field phone_number: %w", err)
		}
		b.PhoneNumber = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field first_name: %w", err)
		}
		b.FirstName = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field last_name: %w", err)
		}
		b.LastName = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field vcard: %w", err)
		}
		b.Vcard = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaContact#18d1cdc2: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaContact) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaContact.
var (
	_ bin.Encoder     = &BotInlineMessageMediaContact{}
	_ bin.Decoder     = &BotInlineMessageMediaContact{}
	_ bin.BareEncoder = &BotInlineMessageMediaContact{}
	_ bin.BareDecoder = &BotInlineMessageMediaContact{}

	_ BotInlineMessageClass = &BotInlineMessageMediaContact{}
)

// BotInlineMessageMediaInvoice represents TL type `botInlineMessageMediaInvoice#354a9b09`.
//
// See https://core.telegram.org/constructor/botInlineMessageMediaInvoice for reference.
type BotInlineMessageMediaInvoice struct {
	// Flags field of BotInlineMessageMediaInvoice.
	Flags bin.Fields
	// ShippingAddressRequested field of BotInlineMessageMediaInvoice.
	ShippingAddressRequested bool
	// Test field of BotInlineMessageMediaInvoice.
	Test bool
	// Title field of BotInlineMessageMediaInvoice.
	Title string
	// Description field of BotInlineMessageMediaInvoice.
	Description string
	// Photo field of BotInlineMessageMediaInvoice.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo WebDocumentClass
	// Currency field of BotInlineMessageMediaInvoice.
	Currency string
	// TotalAmount field of BotInlineMessageMediaInvoice.
	TotalAmount int64
	// ReplyMarkup field of BotInlineMessageMediaInvoice.
	//
	// Use SetReplyMarkup and GetReplyMarkup helpers.
	ReplyMarkup ReplyMarkupClass
}

// BotInlineMessageMediaInvoiceTypeID is TL type id of BotInlineMessageMediaInvoice.
const BotInlineMessageMediaInvoiceTypeID = 0x354a9b09

func (b *BotInlineMessageMediaInvoice) Zero() bool {
	if b == nil {
		return true
	}
	if !(b.Flags.Zero()) {
		return false
	}
	if !(b.ShippingAddressRequested == false) {
		return false
	}
	if !(b.Test == false) {
		return false
	}
	if !(b.Title == "") {
		return false
	}
	if !(b.Description == "") {
		return false
	}
	if !(b.Photo == nil) {
		return false
	}
	if !(b.Currency == "") {
		return false
	}
	if !(b.TotalAmount == 0) {
		return false
	}
	if !(b.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (b *BotInlineMessageMediaInvoice) String() string {
	if b == nil {
		return "BotInlineMessageMediaInvoice(nil)"
	}
	type Alias BotInlineMessageMediaInvoice
	return fmt.Sprintf("BotInlineMessageMediaInvoice%+v", Alias(*b))
}

// FillFrom fills BotInlineMessageMediaInvoice from given interface.
func (b *BotInlineMessageMediaInvoice) FillFrom(from interface {
	GetShippingAddressRequested() (value bool)
	GetTest() (value bool)
	GetTitle() (value string)
	GetDescription() (value string)
	GetPhoto() (value WebDocumentClass, ok bool)
	GetCurrency() (value string)
	GetTotalAmount() (value int64)
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}) {
	b.ShippingAddressRequested = from.GetShippingAddressRequested()
	b.Test = from.GetTest()
	b.Title = from.GetTitle()
	b.Description = from.GetDescription()
	if val, ok := from.GetPhoto(); ok {
		b.Photo = val
	}

	b.Currency = from.GetCurrency()
	b.TotalAmount = from.GetTotalAmount()
	if val, ok := from.GetReplyMarkup(); ok {
		b.ReplyMarkup = val
	}

}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*BotInlineMessageMediaInvoice) TypeID() uint32 {
	return BotInlineMessageMediaInvoiceTypeID
}

// TypeName returns name of type in TL schema.
func (*BotInlineMessageMediaInvoice) TypeName() string {
	return "botInlineMessageMediaInvoice"
}

// TypeInfo returns info about TL type.
func (b *BotInlineMessageMediaInvoice) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "botInlineMessageMediaInvoice",
		ID:   BotInlineMessageMediaInvoiceTypeID,
	}
	if b == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ShippingAddressRequested",
			SchemaName: "shipping_address_requested",
			Null:       !b.Flags.Has(1),
		},
		{
			Name:       "Test",
			SchemaName: "test",
			Null:       !b.Flags.Has(3),
		},
		{
			Name:       "Title",
			SchemaName: "title",
		},
		{
			Name:       "Description",
			SchemaName: "description",
		},
		{
			Name:       "Photo",
			SchemaName: "photo",
			Null:       !b.Flags.Has(0),
		},
		{
			Name:       "Currency",
			SchemaName: "currency",
		},
		{
			Name:       "TotalAmount",
			SchemaName: "total_amount",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
			Null:       !b.Flags.Has(2),
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (b *BotInlineMessageMediaInvoice) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaInvoice#354a9b09 as nil")
	}
	buf.PutID(BotInlineMessageMediaInvoiceTypeID)
	return b.EncodeBare(buf)
}

// EncodeBare implements bin.BareEncoder.
func (b *BotInlineMessageMediaInvoice) EncodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode botInlineMessageMediaInvoice#354a9b09 as nil")
	}
	if !(b.ShippingAddressRequested == false) {
		b.Flags.Set(1)
	}
	if !(b.Test == false) {
		b.Flags.Set(3)
	}
	if !(b.Photo == nil) {
		b.Flags.Set(0)
	}
	if !(b.ReplyMarkup == nil) {
		b.Flags.Set(2)
	}
	if err := b.Flags.Encode(buf); err != nil {
		return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field flags: %w", err)
	}
	buf.PutString(b.Title)
	buf.PutString(b.Description)
	if b.Flags.Has(0) {
		if b.Photo == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field photo is nil")
		}
		if err := b.Photo.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field photo: %w", err)
		}
	}
	buf.PutString(b.Currency)
	buf.PutLong(b.TotalAmount)
	if b.Flags.Has(2) {
		if b.ReplyMarkup == nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field reply_markup is nil")
		}
		if err := b.ReplyMarkup.Encode(buf); err != nil {
			return fmt.Errorf("unable to encode botInlineMessageMediaInvoice#354a9b09: field reply_markup: %w", err)
		}
	}
	return nil
}

// SetShippingAddressRequested sets value of ShippingAddressRequested conditional field.
func (b *BotInlineMessageMediaInvoice) SetShippingAddressRequested(value bool) {
	if value {
		b.Flags.Set(1)
		b.ShippingAddressRequested = true
	} else {
		b.Flags.Unset(1)
		b.ShippingAddressRequested = false
	}
}

// GetShippingAddressRequested returns value of ShippingAddressRequested conditional field.
func (b *BotInlineMessageMediaInvoice) GetShippingAddressRequested() (value bool) {
	return b.Flags.Has(1)
}

// SetTest sets value of Test conditional field.
func (b *BotInlineMessageMediaInvoice) SetTest(value bool) {
	if value {
		b.Flags.Set(3)
		b.Test = true
	} else {
		b.Flags.Unset(3)
		b.Test = false
	}
}

// GetTest returns value of Test conditional field.
func (b *BotInlineMessageMediaInvoice) GetTest() (value bool) {
	return b.Flags.Has(3)
}

// GetTitle returns value of Title field.
func (b *BotInlineMessageMediaInvoice) GetTitle() (value string) {
	return b.Title
}

// GetDescription returns value of Description field.
func (b *BotInlineMessageMediaInvoice) GetDescription() (value string) {
	return b.Description
}

// SetPhoto sets value of Photo conditional field.
func (b *BotInlineMessageMediaInvoice) SetPhoto(value WebDocumentClass) {
	b.Flags.Set(0)
	b.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaInvoice) GetPhoto() (value WebDocumentClass, ok bool) {
	if !b.Flags.Has(0) {
		return value, false
	}
	return b.Photo, true
}

// GetCurrency returns value of Currency field.
func (b *BotInlineMessageMediaInvoice) GetCurrency() (value string) {
	return b.Currency
}

// GetTotalAmount returns value of TotalAmount field.
func (b *BotInlineMessageMediaInvoice) GetTotalAmount() (value int64) {
	return b.TotalAmount
}

// SetReplyMarkup sets value of ReplyMarkup conditional field.
func (b *BotInlineMessageMediaInvoice) SetReplyMarkup(value ReplyMarkupClass) {
	b.Flags.Set(2)
	b.ReplyMarkup = value
}

// GetReplyMarkup returns value of ReplyMarkup conditional field and
// boolean which is true if field was set.
func (b *BotInlineMessageMediaInvoice) GetReplyMarkup() (value ReplyMarkupClass, ok bool) {
	if !b.Flags.Has(2) {
		return value, false
	}
	return b.ReplyMarkup, true
}

// Decode implements bin.Decoder.
func (b *BotInlineMessageMediaInvoice) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaInvoice#354a9b09 to nil")
	}
	if err := buf.ConsumeID(BotInlineMessageMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: %w", err)
	}
	return b.DecodeBare(buf)
}

// DecodeBare implements bin.BareDecoder.
func (b *BotInlineMessageMediaInvoice) DecodeBare(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode botInlineMessageMediaInvoice#354a9b09 to nil")
	}
	{
		if err := b.Flags.Decode(buf); err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field flags: %w", err)
		}
	}
	b.ShippingAddressRequested = b.Flags.Has(1)
	b.Test = b.Flags.Has(3)
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field title: %w", err)
		}
		b.Title = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field description: %w", err)
		}
		b.Description = value
	}
	if b.Flags.Has(0) {
		value, err := DecodeWebDocument(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field photo: %w", err)
		}
		b.Photo = value
	}
	{
		value, err := buf.String()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field currency: %w", err)
		}
		b.Currency = value
	}
	{
		value, err := buf.Long()
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field total_amount: %w", err)
		}
		b.TotalAmount = value
	}
	if b.Flags.Has(2) {
		value, err := DecodeReplyMarkup(buf)
		if err != nil {
			return fmt.Errorf("unable to decode botInlineMessageMediaInvoice#354a9b09: field reply_markup: %w", err)
		}
		b.ReplyMarkup = value
	}
	return nil
}

// construct implements constructor of BotInlineMessageClass.
func (b BotInlineMessageMediaInvoice) construct() BotInlineMessageClass { return &b }

// Ensuring interfaces in compile-time for BotInlineMessageMediaInvoice.
var (
	_ bin.Encoder     = &BotInlineMessageMediaInvoice{}
	_ bin.Decoder     = &BotInlineMessageMediaInvoice{}
	_ bin.BareEncoder = &BotInlineMessageMediaInvoice{}
	_ bin.BareDecoder = &BotInlineMessageMediaInvoice{}

	_ BotInlineMessageClass = &BotInlineMessageMediaInvoice{}
)

// BotInlineMessageClass represents BotInlineMessage generic type.
//
// See https://core.telegram.org/type/BotInlineMessage for reference.
//
// Example:
//  g, err := tg.DecodeBotInlineMessage(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.BotInlineMessageMediaAuto: // botInlineMessageMediaAuto#764cf810
//  case *tg.BotInlineMessageText: // botInlineMessageText#8c7f65e2
//  case *tg.BotInlineMessageMediaGeo: // botInlineMessageMediaGeo#51846fd
//  case *tg.BotInlineMessageMediaVenue: // botInlineMessageMediaVenue#8a86659c
//  case *tg.BotInlineMessageMediaContact: // botInlineMessageMediaContact#18d1cdc2
//  case *tg.BotInlineMessageMediaInvoice: // botInlineMessageMediaInvoice#354a9b09
//  default: panic(v)
//  }
type BotInlineMessageClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	tdp.Object
	construct() BotInlineMessageClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeInfo returns TL type info.
	TypeInfo() tdp.Type
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// Inline keyboard
	GetReplyMarkup() (value ReplyMarkupClass, ok bool)
}

// DecodeBotInlineMessage implements binary de-serialization for BotInlineMessageClass.
func DecodeBotInlineMessage(buf *bin.Buffer) (BotInlineMessageClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case BotInlineMessageMediaAutoTypeID:
		// Decoding botInlineMessageMediaAuto#764cf810.
		v := BotInlineMessageMediaAuto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageTextTypeID:
		// Decoding botInlineMessageText#8c7f65e2.
		v := BotInlineMessageText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaGeoTypeID:
		// Decoding botInlineMessageMediaGeo#51846fd.
		v := BotInlineMessageMediaGeo{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaVenueTypeID:
		// Decoding botInlineMessageMediaVenue#8a86659c.
		v := BotInlineMessageMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaContactTypeID:
		// Decoding botInlineMessageMediaContact#18d1cdc2.
		v := BotInlineMessageMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	case BotInlineMessageMediaInvoiceTypeID:
		// Decoding botInlineMessageMediaInvoice#354a9b09.
		v := BotInlineMessageMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode BotInlineMessageClass: %w", bin.NewUnexpectedID(id))
	}
}

// BotInlineMessage boxes the BotInlineMessageClass providing a helper.
type BotInlineMessageBox struct {
	BotInlineMessage BotInlineMessageClass
}

// TypeInfo implements tdp.Object for BotInlineMessageBox.
func (b *BotInlineMessageBox) TypeInfo() tdp.Type {
	return b.BotInlineMessage.TypeInfo()
}

// Decode implements bin.Decoder for BotInlineMessageBox.
func (b *BotInlineMessageBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode BotInlineMessageBox to nil")
	}
	v, err := DecodeBotInlineMessage(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.BotInlineMessage = v
	return nil
}

// Encode implements bin.Encode for BotInlineMessageBox.
func (b *BotInlineMessageBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.BotInlineMessage == nil {
		return fmt.Errorf("unable to encode BotInlineMessageClass as nil")
	}
	return b.BotInlineMessage.Encode(buf)
}

// BotInlineMessageClassArray is adapter for slice of BotInlineMessageClass.
type BotInlineMessageClassArray []BotInlineMessageClass

// Sort sorts slice of BotInlineMessageClass.
func (s BotInlineMessageClassArray) Sort(less func(a, b BotInlineMessageClass) bool) BotInlineMessageClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of BotInlineMessageClass.
func (s BotInlineMessageClassArray) SortStable(less func(a, b BotInlineMessageClass) bool) BotInlineMessageClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of BotInlineMessageClass.
func (s BotInlineMessageClassArray) Retain(keep func(x BotInlineMessageClass) bool) BotInlineMessageClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s BotInlineMessageClassArray) First() (v BotInlineMessageClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s BotInlineMessageClassArray) Last() (v BotInlineMessageClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *BotInlineMessageClassArray) PopFirst() (v BotInlineMessageClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero BotInlineMessageClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *BotInlineMessageClassArray) Pop() (v BotInlineMessageClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsBotInlineMessageMediaAuto returns copy with only BotInlineMessageMediaAuto constructors.
func (s BotInlineMessageClassArray) AsBotInlineMessageMediaAuto() (to BotInlineMessageMediaAutoArray) {
	for _, elem := range s {
		value, ok := elem.(*BotInlineMessageMediaAuto)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsBotInlineMessageText returns copy with only BotInlineMessageText constructors.
func (s BotInlineMessageClassArray) AsBotInlineMessageText() (to BotInlineMessageTextArray) {
	for _, elem := range s {
		value, ok := elem.(*BotInlineMessageText)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsBotInlineMessageMediaGeo returns copy with only BotInlineMessageMediaGeo constructors.
func (s BotInlineMessageClassArray) AsBotInlineMessageMediaGeo() (to BotInlineMessageMediaGeoArray) {
	for _, elem := range s {
		value, ok := elem.(*BotInlineMessageMediaGeo)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsBotInlineMessageMediaVenue returns copy with only BotInlineMessageMediaVenue constructors.
func (s BotInlineMessageClassArray) AsBotInlineMessageMediaVenue() (to BotInlineMessageMediaVenueArray) {
	for _, elem := range s {
		value, ok := elem.(*BotInlineMessageMediaVenue)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsBotInlineMessageMediaContact returns copy with only BotInlineMessageMediaContact constructors.
func (s BotInlineMessageClassArray) AsBotInlineMessageMediaContact() (to BotInlineMessageMediaContactArray) {
	for _, elem := range s {
		value, ok := elem.(*BotInlineMessageMediaContact)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsBotInlineMessageMediaInvoice returns copy with only BotInlineMessageMediaInvoice constructors.
func (s BotInlineMessageClassArray) AsBotInlineMessageMediaInvoice() (to BotInlineMessageMediaInvoiceArray) {
	for _, elem := range s {
		value, ok := elem.(*BotInlineMessageMediaInvoice)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// BotInlineMessageMediaAutoArray is adapter for slice of BotInlineMessageMediaAuto.
type BotInlineMessageMediaAutoArray []BotInlineMessageMediaAuto

// Sort sorts slice of BotInlineMessageMediaAuto.
func (s BotInlineMessageMediaAutoArray) Sort(less func(a, b BotInlineMessageMediaAuto) bool) BotInlineMessageMediaAutoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of BotInlineMessageMediaAuto.
func (s BotInlineMessageMediaAutoArray) SortStable(less func(a, b BotInlineMessageMediaAuto) bool) BotInlineMessageMediaAutoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of BotInlineMessageMediaAuto.
func (s BotInlineMessageMediaAutoArray) Retain(keep func(x BotInlineMessageMediaAuto) bool) BotInlineMessageMediaAutoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s BotInlineMessageMediaAutoArray) First() (v BotInlineMessageMediaAuto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s BotInlineMessageMediaAutoArray) Last() (v BotInlineMessageMediaAuto, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaAutoArray) PopFirst() (v BotInlineMessageMediaAuto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero BotInlineMessageMediaAuto
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaAutoArray) Pop() (v BotInlineMessageMediaAuto, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// BotInlineMessageTextArray is adapter for slice of BotInlineMessageText.
type BotInlineMessageTextArray []BotInlineMessageText

// Sort sorts slice of BotInlineMessageText.
func (s BotInlineMessageTextArray) Sort(less func(a, b BotInlineMessageText) bool) BotInlineMessageTextArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of BotInlineMessageText.
func (s BotInlineMessageTextArray) SortStable(less func(a, b BotInlineMessageText) bool) BotInlineMessageTextArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of BotInlineMessageText.
func (s BotInlineMessageTextArray) Retain(keep func(x BotInlineMessageText) bool) BotInlineMessageTextArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s BotInlineMessageTextArray) First() (v BotInlineMessageText, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s BotInlineMessageTextArray) Last() (v BotInlineMessageText, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *BotInlineMessageTextArray) PopFirst() (v BotInlineMessageText, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero BotInlineMessageText
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *BotInlineMessageTextArray) Pop() (v BotInlineMessageText, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// BotInlineMessageMediaGeoArray is adapter for slice of BotInlineMessageMediaGeo.
type BotInlineMessageMediaGeoArray []BotInlineMessageMediaGeo

// Sort sorts slice of BotInlineMessageMediaGeo.
func (s BotInlineMessageMediaGeoArray) Sort(less func(a, b BotInlineMessageMediaGeo) bool) BotInlineMessageMediaGeoArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of BotInlineMessageMediaGeo.
func (s BotInlineMessageMediaGeoArray) SortStable(less func(a, b BotInlineMessageMediaGeo) bool) BotInlineMessageMediaGeoArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of BotInlineMessageMediaGeo.
func (s BotInlineMessageMediaGeoArray) Retain(keep func(x BotInlineMessageMediaGeo) bool) BotInlineMessageMediaGeoArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s BotInlineMessageMediaGeoArray) First() (v BotInlineMessageMediaGeo, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s BotInlineMessageMediaGeoArray) Last() (v BotInlineMessageMediaGeo, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaGeoArray) PopFirst() (v BotInlineMessageMediaGeo, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero BotInlineMessageMediaGeo
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaGeoArray) Pop() (v BotInlineMessageMediaGeo, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// BotInlineMessageMediaVenueArray is adapter for slice of BotInlineMessageMediaVenue.
type BotInlineMessageMediaVenueArray []BotInlineMessageMediaVenue

// Sort sorts slice of BotInlineMessageMediaVenue.
func (s BotInlineMessageMediaVenueArray) Sort(less func(a, b BotInlineMessageMediaVenue) bool) BotInlineMessageMediaVenueArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of BotInlineMessageMediaVenue.
func (s BotInlineMessageMediaVenueArray) SortStable(less func(a, b BotInlineMessageMediaVenue) bool) BotInlineMessageMediaVenueArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of BotInlineMessageMediaVenue.
func (s BotInlineMessageMediaVenueArray) Retain(keep func(x BotInlineMessageMediaVenue) bool) BotInlineMessageMediaVenueArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s BotInlineMessageMediaVenueArray) First() (v BotInlineMessageMediaVenue, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s BotInlineMessageMediaVenueArray) Last() (v BotInlineMessageMediaVenue, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaVenueArray) PopFirst() (v BotInlineMessageMediaVenue, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero BotInlineMessageMediaVenue
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaVenueArray) Pop() (v BotInlineMessageMediaVenue, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// BotInlineMessageMediaContactArray is adapter for slice of BotInlineMessageMediaContact.
type BotInlineMessageMediaContactArray []BotInlineMessageMediaContact

// Sort sorts slice of BotInlineMessageMediaContact.
func (s BotInlineMessageMediaContactArray) Sort(less func(a, b BotInlineMessageMediaContact) bool) BotInlineMessageMediaContactArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of BotInlineMessageMediaContact.
func (s BotInlineMessageMediaContactArray) SortStable(less func(a, b BotInlineMessageMediaContact) bool) BotInlineMessageMediaContactArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of BotInlineMessageMediaContact.
func (s BotInlineMessageMediaContactArray) Retain(keep func(x BotInlineMessageMediaContact) bool) BotInlineMessageMediaContactArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s BotInlineMessageMediaContactArray) First() (v BotInlineMessageMediaContact, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s BotInlineMessageMediaContactArray) Last() (v BotInlineMessageMediaContact, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaContactArray) PopFirst() (v BotInlineMessageMediaContact, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero BotInlineMessageMediaContact
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaContactArray) Pop() (v BotInlineMessageMediaContact, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// BotInlineMessageMediaInvoiceArray is adapter for slice of BotInlineMessageMediaInvoice.
type BotInlineMessageMediaInvoiceArray []BotInlineMessageMediaInvoice

// Sort sorts slice of BotInlineMessageMediaInvoice.
func (s BotInlineMessageMediaInvoiceArray) Sort(less func(a, b BotInlineMessageMediaInvoice) bool) BotInlineMessageMediaInvoiceArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of BotInlineMessageMediaInvoice.
func (s BotInlineMessageMediaInvoiceArray) SortStable(less func(a, b BotInlineMessageMediaInvoice) bool) BotInlineMessageMediaInvoiceArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of BotInlineMessageMediaInvoice.
func (s BotInlineMessageMediaInvoiceArray) Retain(keep func(x BotInlineMessageMediaInvoice) bool) BotInlineMessageMediaInvoiceArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s BotInlineMessageMediaInvoiceArray) First() (v BotInlineMessageMediaInvoice, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s BotInlineMessageMediaInvoiceArray) Last() (v BotInlineMessageMediaInvoice, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaInvoiceArray) PopFirst() (v BotInlineMessageMediaInvoice, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero BotInlineMessageMediaInvoice
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *BotInlineMessageMediaInvoiceArray) Pop() (v BotInlineMessageMediaInvoice, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
