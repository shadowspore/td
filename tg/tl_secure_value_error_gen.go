// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
)

// SecureValueErrorData represents TL type `secureValueErrorData#e8a40bd9`.
// Represents an issue in one of the data fields that was provided by the user. The error
// is considered resolved when the field's value changes.
//
// See https://core.telegram.org/constructor/secureValueErrorData for reference.
type SecureValueErrorData struct {
	// The section of the user's Telegram Passport which has the error, one of
	// secureValueTypePersonalDetails¹, secureValueTypePassport²,
	// secureValueTypeDriverLicense³, secureValueTypeIdentityCard⁴,
	// secureValueTypeInternalPassport⁵, secureValueTypeAddress⁶
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypePersonalDetails
	//  2) https://core.telegram.org/constructor/secureValueTypePassport
	//  3) https://core.telegram.org/constructor/secureValueTypeDriverLicense
	//  4) https://core.telegram.org/constructor/secureValueTypeIdentityCard
	//  5) https://core.telegram.org/constructor/secureValueTypeInternalPassport
	//  6) https://core.telegram.org/constructor/secureValueTypeAddress
	Type SecureValueTypeClass
	// Data hash
	DataHash []byte
	// Name of the data field which has the error
	Field string
	// Error message
	Text string
}

// SecureValueErrorDataTypeID is TL type id of SecureValueErrorData.
const SecureValueErrorDataTypeID = 0xe8a40bd9

func (s *SecureValueErrorData) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.DataHash == nil) {
		return false
	}
	if !(s.Field == "") {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorData) String() string {
	if s == nil {
		return "SecureValueErrorData(nil)"
	}
	type Alias SecureValueErrorData
	return fmt.Sprintf("SecureValueErrorData%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorData from given interface.
func (s *SecureValueErrorData) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetDataHash() (value []byte)
	GetField() (value string)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.DataHash = from.GetDataHash()
	s.Field = from.GetField()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorData) TypeID() uint32 {
	return SecureValueErrorDataTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorData) TypeName() string {
	return "secureValueErrorData"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorData) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorData",
		ID:   SecureValueErrorDataTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "DataHash",
			SchemaName: "data_hash",
		},
		{
			Name:       "Field",
			SchemaName: "field",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorData) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorData#e8a40bd9 as nil")
	}
	b.PutID(SecureValueErrorDataTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorData) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorData#e8a40bd9 as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorData#e8a40bd9: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorData#e8a40bd9: field type: %w", err)
	}
	b.PutBytes(s.DataHash)
	b.PutString(s.Field)
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorData) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetDataHash returns value of DataHash field.
func (s *SecureValueErrorData) GetDataHash() (value []byte) {
	return s.DataHash
}

// GetField returns value of Field field.
func (s *SecureValueErrorData) GetField() (value string) {
	return s.Field
}

// GetText returns value of Text field.
func (s *SecureValueErrorData) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorData) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorData#e8a40bd9 to nil")
	}
	if err := b.ConsumeID(SecureValueErrorDataTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorData#e8a40bd9: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorData) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorData#e8a40bd9 to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorData#e8a40bd9: field type: %w", err)
		}
		s.Type = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorData#e8a40bd9: field data_hash: %w", err)
		}
		s.DataHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorData#e8a40bd9: field field: %w", err)
		}
		s.Field = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorData#e8a40bd9: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorData) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorData.
var (
	_ bin.Encoder     = &SecureValueErrorData{}
	_ bin.Decoder     = &SecureValueErrorData{}
	_ bin.BareEncoder = &SecureValueErrorData{}
	_ bin.BareDecoder = &SecureValueErrorData{}

	_ SecureValueErrorClass = &SecureValueErrorData{}
)

// SecureValueErrorFrontSide represents TL type `secureValueErrorFrontSide#be3dfa`.
// Represents an issue with the front side of a document. The error is considered
// resolved when the file with the front side of the document changes.
//
// See https://core.telegram.org/constructor/secureValueErrorFrontSide for reference.
type SecureValueErrorFrontSide struct {
	// One of secureValueTypePassport¹, secureValueTypeDriverLicense²,
	// secureValueTypeIdentityCard³, secureValueTypeInternalPassport⁴
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypePassport
	//  2) https://core.telegram.org/constructor/secureValueTypeDriverLicense
	//  3) https://core.telegram.org/constructor/secureValueTypeIdentityCard
	//  4) https://core.telegram.org/constructor/secureValueTypeInternalPassport
	Type SecureValueTypeClass
	// File hash
	FileHash []byte
	// Error message
	Text string
}

// SecureValueErrorFrontSideTypeID is TL type id of SecureValueErrorFrontSide.
const SecureValueErrorFrontSideTypeID = 0xbe3dfa

func (s *SecureValueErrorFrontSide) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.FileHash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorFrontSide) String() string {
	if s == nil {
		return "SecureValueErrorFrontSide(nil)"
	}
	type Alias SecureValueErrorFrontSide
	return fmt.Sprintf("SecureValueErrorFrontSide%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorFrontSide from given interface.
func (s *SecureValueErrorFrontSide) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetFileHash() (value []byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.FileHash = from.GetFileHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorFrontSide) TypeID() uint32 {
	return SecureValueErrorFrontSideTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorFrontSide) TypeName() string {
	return "secureValueErrorFrontSide"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorFrontSide) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorFrontSide",
		ID:   SecureValueErrorFrontSideTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorFrontSide) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorFrontSide#be3dfa as nil")
	}
	b.PutID(SecureValueErrorFrontSideTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorFrontSide) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorFrontSide#be3dfa as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorFrontSide#be3dfa: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorFrontSide#be3dfa: field type: %w", err)
	}
	b.PutBytes(s.FileHash)
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorFrontSide) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetFileHash returns value of FileHash field.
func (s *SecureValueErrorFrontSide) GetFileHash() (value []byte) {
	return s.FileHash
}

// GetText returns value of Text field.
func (s *SecureValueErrorFrontSide) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorFrontSide) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorFrontSide#be3dfa to nil")
	}
	if err := b.ConsumeID(SecureValueErrorFrontSideTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorFrontSide#be3dfa: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorFrontSide) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorFrontSide#be3dfa to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFrontSide#be3dfa: field type: %w", err)
		}
		s.Type = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFrontSide#be3dfa: field file_hash: %w", err)
		}
		s.FileHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFrontSide#be3dfa: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorFrontSide) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorFrontSide.
var (
	_ bin.Encoder     = &SecureValueErrorFrontSide{}
	_ bin.Decoder     = &SecureValueErrorFrontSide{}
	_ bin.BareEncoder = &SecureValueErrorFrontSide{}
	_ bin.BareDecoder = &SecureValueErrorFrontSide{}

	_ SecureValueErrorClass = &SecureValueErrorFrontSide{}
)

// SecureValueErrorReverseSide represents TL type `secureValueErrorReverseSide#868a2aa5`.
// Represents an issue with the reverse side of a document. The error is considered
// resolved when the file with reverse side of the document changes.
//
// See https://core.telegram.org/constructor/secureValueErrorReverseSide for reference.
type SecureValueErrorReverseSide struct {
	// One of secureValueTypeDriverLicense¹, secureValueTypeIdentityCard²
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypeDriverLicense
	//  2) https://core.telegram.org/constructor/secureValueTypeIdentityCard
	Type SecureValueTypeClass
	// File hash
	FileHash []byte
	// Error message
	Text string
}

// SecureValueErrorReverseSideTypeID is TL type id of SecureValueErrorReverseSide.
const SecureValueErrorReverseSideTypeID = 0x868a2aa5

func (s *SecureValueErrorReverseSide) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.FileHash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorReverseSide) String() string {
	if s == nil {
		return "SecureValueErrorReverseSide(nil)"
	}
	type Alias SecureValueErrorReverseSide
	return fmt.Sprintf("SecureValueErrorReverseSide%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorReverseSide from given interface.
func (s *SecureValueErrorReverseSide) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetFileHash() (value []byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.FileHash = from.GetFileHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorReverseSide) TypeID() uint32 {
	return SecureValueErrorReverseSideTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorReverseSide) TypeName() string {
	return "secureValueErrorReverseSide"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorReverseSide) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorReverseSide",
		ID:   SecureValueErrorReverseSideTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorReverseSide) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorReverseSide#868a2aa5 as nil")
	}
	b.PutID(SecureValueErrorReverseSideTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorReverseSide) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorReverseSide#868a2aa5 as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorReverseSide#868a2aa5: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorReverseSide#868a2aa5: field type: %w", err)
	}
	b.PutBytes(s.FileHash)
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorReverseSide) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetFileHash returns value of FileHash field.
func (s *SecureValueErrorReverseSide) GetFileHash() (value []byte) {
	return s.FileHash
}

// GetText returns value of Text field.
func (s *SecureValueErrorReverseSide) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorReverseSide) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorReverseSide#868a2aa5 to nil")
	}
	if err := b.ConsumeID(SecureValueErrorReverseSideTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorReverseSide#868a2aa5: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorReverseSide) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorReverseSide#868a2aa5 to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorReverseSide#868a2aa5: field type: %w", err)
		}
		s.Type = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorReverseSide#868a2aa5: field file_hash: %w", err)
		}
		s.FileHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorReverseSide#868a2aa5: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorReverseSide) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorReverseSide.
var (
	_ bin.Encoder     = &SecureValueErrorReverseSide{}
	_ bin.Decoder     = &SecureValueErrorReverseSide{}
	_ bin.BareEncoder = &SecureValueErrorReverseSide{}
	_ bin.BareDecoder = &SecureValueErrorReverseSide{}

	_ SecureValueErrorClass = &SecureValueErrorReverseSide{}
)

// SecureValueErrorSelfie represents TL type `secureValueErrorSelfie#e537ced6`.
// Represents an issue with the selfie with a document. The error is considered resolved
// when the file with the selfie changes.
//
// See https://core.telegram.org/constructor/secureValueErrorSelfie for reference.
type SecureValueErrorSelfie struct {
	// One of secureValueTypePassport¹, secureValueTypeDriverLicense²,
	// secureValueTypeIdentityCard³, secureValueTypeInternalPassport⁴
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypePassport
	//  2) https://core.telegram.org/constructor/secureValueTypeDriverLicense
	//  3) https://core.telegram.org/constructor/secureValueTypeIdentityCard
	//  4) https://core.telegram.org/constructor/secureValueTypeInternalPassport
	Type SecureValueTypeClass
	// File hash
	FileHash []byte
	// Error message
	Text string
}

// SecureValueErrorSelfieTypeID is TL type id of SecureValueErrorSelfie.
const SecureValueErrorSelfieTypeID = 0xe537ced6

func (s *SecureValueErrorSelfie) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.FileHash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorSelfie) String() string {
	if s == nil {
		return "SecureValueErrorSelfie(nil)"
	}
	type Alias SecureValueErrorSelfie
	return fmt.Sprintf("SecureValueErrorSelfie%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorSelfie from given interface.
func (s *SecureValueErrorSelfie) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetFileHash() (value []byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.FileHash = from.GetFileHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorSelfie) TypeID() uint32 {
	return SecureValueErrorSelfieTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorSelfie) TypeName() string {
	return "secureValueErrorSelfie"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorSelfie) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorSelfie",
		ID:   SecureValueErrorSelfieTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorSelfie) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorSelfie#e537ced6 as nil")
	}
	b.PutID(SecureValueErrorSelfieTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorSelfie) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorSelfie#e537ced6 as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorSelfie#e537ced6: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorSelfie#e537ced6: field type: %w", err)
	}
	b.PutBytes(s.FileHash)
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorSelfie) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetFileHash returns value of FileHash field.
func (s *SecureValueErrorSelfie) GetFileHash() (value []byte) {
	return s.FileHash
}

// GetText returns value of Text field.
func (s *SecureValueErrorSelfie) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorSelfie) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorSelfie#e537ced6 to nil")
	}
	if err := b.ConsumeID(SecureValueErrorSelfieTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorSelfie#e537ced6: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorSelfie) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorSelfie#e537ced6 to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorSelfie#e537ced6: field type: %w", err)
		}
		s.Type = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorSelfie#e537ced6: field file_hash: %w", err)
		}
		s.FileHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorSelfie#e537ced6: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorSelfie) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorSelfie.
var (
	_ bin.Encoder     = &SecureValueErrorSelfie{}
	_ bin.Decoder     = &SecureValueErrorSelfie{}
	_ bin.BareEncoder = &SecureValueErrorSelfie{}
	_ bin.BareDecoder = &SecureValueErrorSelfie{}

	_ SecureValueErrorClass = &SecureValueErrorSelfie{}
)

// SecureValueErrorFile represents TL type `secureValueErrorFile#7a700873`.
// Represents an issue with a document scan. The error is considered resolved when the
// file with the document scan changes.
//
// See https://core.telegram.org/constructor/secureValueErrorFile for reference.
type SecureValueErrorFile struct {
	// One of secureValueTypeUtilityBill¹, secureValueTypeBankStatement²,
	// secureValueTypeRentalAgreement³, secureValueTypePassportRegistration⁴,
	// secureValueTypeTemporaryRegistration⁵
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypeUtilityBill
	//  2) https://core.telegram.org/constructor/secureValueTypeBankStatement
	//  3) https://core.telegram.org/constructor/secureValueTypeRentalAgreement
	//  4) https://core.telegram.org/constructor/secureValueTypePassportRegistration
	//  5) https://core.telegram.org/constructor/secureValueTypeTemporaryRegistration
	Type SecureValueTypeClass
	// File hash
	FileHash []byte
	// Error message
	Text string
}

// SecureValueErrorFileTypeID is TL type id of SecureValueErrorFile.
const SecureValueErrorFileTypeID = 0x7a700873

func (s *SecureValueErrorFile) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.FileHash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorFile) String() string {
	if s == nil {
		return "SecureValueErrorFile(nil)"
	}
	type Alias SecureValueErrorFile
	return fmt.Sprintf("SecureValueErrorFile%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorFile from given interface.
func (s *SecureValueErrorFile) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetFileHash() (value []byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.FileHash = from.GetFileHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorFile) TypeID() uint32 {
	return SecureValueErrorFileTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorFile) TypeName() string {
	return "secureValueErrorFile"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorFile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorFile",
		ID:   SecureValueErrorFileTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorFile) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorFile#7a700873 as nil")
	}
	b.PutID(SecureValueErrorFileTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorFile) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorFile#7a700873 as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorFile#7a700873: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorFile#7a700873: field type: %w", err)
	}
	b.PutBytes(s.FileHash)
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorFile) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetFileHash returns value of FileHash field.
func (s *SecureValueErrorFile) GetFileHash() (value []byte) {
	return s.FileHash
}

// GetText returns value of Text field.
func (s *SecureValueErrorFile) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorFile) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorFile#7a700873 to nil")
	}
	if err := b.ConsumeID(SecureValueErrorFileTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorFile#7a700873: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorFile) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorFile#7a700873 to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFile#7a700873: field type: %w", err)
		}
		s.Type = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFile#7a700873: field file_hash: %w", err)
		}
		s.FileHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFile#7a700873: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorFile) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorFile.
var (
	_ bin.Encoder     = &SecureValueErrorFile{}
	_ bin.Decoder     = &SecureValueErrorFile{}
	_ bin.BareEncoder = &SecureValueErrorFile{}
	_ bin.BareDecoder = &SecureValueErrorFile{}

	_ SecureValueErrorClass = &SecureValueErrorFile{}
)

// SecureValueErrorFiles represents TL type `secureValueErrorFiles#666220e9`.
// Represents an issue with a list of scans. The error is considered resolved when the
// list of files containing the scans changes.
//
// See https://core.telegram.org/constructor/secureValueErrorFiles for reference.
type SecureValueErrorFiles struct {
	// One of secureValueTypeUtilityBill¹, secureValueTypeBankStatement²,
	// secureValueTypeRentalAgreement³, secureValueTypePassportRegistration⁴,
	// secureValueTypeTemporaryRegistration⁵
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypeUtilityBill
	//  2) https://core.telegram.org/constructor/secureValueTypeBankStatement
	//  3) https://core.telegram.org/constructor/secureValueTypeRentalAgreement
	//  4) https://core.telegram.org/constructor/secureValueTypePassportRegistration
	//  5) https://core.telegram.org/constructor/secureValueTypeTemporaryRegistration
	Type SecureValueTypeClass
	// File hash
	FileHash [][]byte
	// Error message
	Text string
}

// SecureValueErrorFilesTypeID is TL type id of SecureValueErrorFiles.
const SecureValueErrorFilesTypeID = 0x666220e9

func (s *SecureValueErrorFiles) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.FileHash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorFiles) String() string {
	if s == nil {
		return "SecureValueErrorFiles(nil)"
	}
	type Alias SecureValueErrorFiles
	return fmt.Sprintf("SecureValueErrorFiles%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorFiles from given interface.
func (s *SecureValueErrorFiles) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetFileHash() (value [][]byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.FileHash = from.GetFileHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorFiles) TypeID() uint32 {
	return SecureValueErrorFilesTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorFiles) TypeName() string {
	return "secureValueErrorFiles"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorFiles) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorFiles",
		ID:   SecureValueErrorFilesTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorFiles) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorFiles#666220e9 as nil")
	}
	b.PutID(SecureValueErrorFilesTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorFiles) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorFiles#666220e9 as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorFiles#666220e9: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorFiles#666220e9: field type: %w", err)
	}
	b.PutVectorHeader(len(s.FileHash))
	for _, v := range s.FileHash {
		b.PutBytes(v)
	}
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorFiles) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetFileHash returns value of FileHash field.
func (s *SecureValueErrorFiles) GetFileHash() (value [][]byte) {
	return s.FileHash
}

// GetText returns value of Text field.
func (s *SecureValueErrorFiles) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorFiles) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorFiles#666220e9 to nil")
	}
	if err := b.ConsumeID(SecureValueErrorFilesTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorFiles#666220e9: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorFiles) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorFiles#666220e9 to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFiles#666220e9: field type: %w", err)
		}
		s.Type = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFiles#666220e9: field file_hash: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode secureValueErrorFiles#666220e9: field file_hash: %w", err)
			}
			s.FileHash = append(s.FileHash, value)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorFiles#666220e9: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorFiles) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorFiles.
var (
	_ bin.Encoder     = &SecureValueErrorFiles{}
	_ bin.Decoder     = &SecureValueErrorFiles{}
	_ bin.BareEncoder = &SecureValueErrorFiles{}
	_ bin.BareDecoder = &SecureValueErrorFiles{}

	_ SecureValueErrorClass = &SecureValueErrorFiles{}
)

// SecureValueError represents TL type `secureValueError#869d758f`.
// Secure value error
//
// See https://core.telegram.org/constructor/secureValueError for reference.
type SecureValueError struct {
	// Type of element which has the issue
	Type SecureValueTypeClass
	// Hash
	Hash []byte
	// Error message
	Text string
}

// SecureValueErrorTypeID is TL type id of SecureValueError.
const SecureValueErrorTypeID = 0x869d758f

func (s *SecureValueError) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.Hash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueError) String() string {
	if s == nil {
		return "SecureValueError(nil)"
	}
	type Alias SecureValueError
	return fmt.Sprintf("SecureValueError%+v", Alias(*s))
}

// FillFrom fills SecureValueError from given interface.
func (s *SecureValueError) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetHash() (value []byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.Hash = from.GetHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueError) TypeID() uint32 {
	return SecureValueErrorTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueError) TypeName() string {
	return "secureValueError"
}

// TypeInfo returns info about TL type.
func (s *SecureValueError) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueError",
		ID:   SecureValueErrorTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "Hash",
			SchemaName: "hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueError) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueError#869d758f as nil")
	}
	b.PutID(SecureValueErrorTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueError) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueError#869d758f as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueError#869d758f: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueError#869d758f: field type: %w", err)
	}
	b.PutBytes(s.Hash)
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueError) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetHash returns value of Hash field.
func (s *SecureValueError) GetHash() (value []byte) {
	return s.Hash
}

// GetText returns value of Text field.
func (s *SecureValueError) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueError) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueError#869d758f to nil")
	}
	if err := b.ConsumeID(SecureValueErrorTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueError#869d758f: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueError) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueError#869d758f to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueError#869d758f: field type: %w", err)
		}
		s.Type = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueError#869d758f: field hash: %w", err)
		}
		s.Hash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueError#869d758f: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueError) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueError.
var (
	_ bin.Encoder     = &SecureValueError{}
	_ bin.Decoder     = &SecureValueError{}
	_ bin.BareEncoder = &SecureValueError{}
	_ bin.BareDecoder = &SecureValueError{}

	_ SecureValueErrorClass = &SecureValueError{}
)

// SecureValueErrorTranslationFile represents TL type `secureValueErrorTranslationFile#a1144770`.
// Represents an issue with one of the files that constitute the translation of a
// document. The error is considered resolved when the file changes.
//
// See https://core.telegram.org/constructor/secureValueErrorTranslationFile for reference.
type SecureValueErrorTranslationFile struct {
	// One of secureValueTypePersonalDetails¹, secureValueTypePassport²,
	// secureValueTypeDriverLicense³, secureValueTypeIdentityCard⁴,
	// secureValueTypeInternalPassport⁵, secureValueTypeUtilityBill⁶,
	// secureValueTypeBankStatement⁷, secureValueTypeRentalAgreement⁸,
	// secureValueTypePassportRegistration⁹, secureValueTypeTemporaryRegistration¹⁰
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypePersonalDetails
	//  2) https://core.telegram.org/constructor/secureValueTypePassport
	//  3) https://core.telegram.org/constructor/secureValueTypeDriverLicense
	//  4) https://core.telegram.org/constructor/secureValueTypeIdentityCard
	//  5) https://core.telegram.org/constructor/secureValueTypeInternalPassport
	//  6) https://core.telegram.org/constructor/secureValueTypeUtilityBill
	//  7) https://core.telegram.org/constructor/secureValueTypeBankStatement
	//  8) https://core.telegram.org/constructor/secureValueTypeRentalAgreement
	//  9) https://core.telegram.org/constructor/secureValueTypePassportRegistration
	//  10) https://core.telegram.org/constructor/secureValueTypeTemporaryRegistration
	Type SecureValueTypeClass
	// File hash
	FileHash []byte
	// Error message
	Text string
}

// SecureValueErrorTranslationFileTypeID is TL type id of SecureValueErrorTranslationFile.
const SecureValueErrorTranslationFileTypeID = 0xa1144770

func (s *SecureValueErrorTranslationFile) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.FileHash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorTranslationFile) String() string {
	if s == nil {
		return "SecureValueErrorTranslationFile(nil)"
	}
	type Alias SecureValueErrorTranslationFile
	return fmt.Sprintf("SecureValueErrorTranslationFile%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorTranslationFile from given interface.
func (s *SecureValueErrorTranslationFile) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetFileHash() (value []byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.FileHash = from.GetFileHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorTranslationFile) TypeID() uint32 {
	return SecureValueErrorTranslationFileTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorTranslationFile) TypeName() string {
	return "secureValueErrorTranslationFile"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorTranslationFile) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorTranslationFile",
		ID:   SecureValueErrorTranslationFileTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorTranslationFile) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorTranslationFile#a1144770 as nil")
	}
	b.PutID(SecureValueErrorTranslationFileTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorTranslationFile) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorTranslationFile#a1144770 as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorTranslationFile#a1144770: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorTranslationFile#a1144770: field type: %w", err)
	}
	b.PutBytes(s.FileHash)
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorTranslationFile) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetFileHash returns value of FileHash field.
func (s *SecureValueErrorTranslationFile) GetFileHash() (value []byte) {
	return s.FileHash
}

// GetText returns value of Text field.
func (s *SecureValueErrorTranslationFile) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorTranslationFile) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorTranslationFile#a1144770 to nil")
	}
	if err := b.ConsumeID(SecureValueErrorTranslationFileTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorTranslationFile#a1144770: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorTranslationFile) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorTranslationFile#a1144770 to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorTranslationFile#a1144770: field type: %w", err)
		}
		s.Type = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorTranslationFile#a1144770: field file_hash: %w", err)
		}
		s.FileHash = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorTranslationFile#a1144770: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorTranslationFile) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorTranslationFile.
var (
	_ bin.Encoder     = &SecureValueErrorTranslationFile{}
	_ bin.Decoder     = &SecureValueErrorTranslationFile{}
	_ bin.BareEncoder = &SecureValueErrorTranslationFile{}
	_ bin.BareDecoder = &SecureValueErrorTranslationFile{}

	_ SecureValueErrorClass = &SecureValueErrorTranslationFile{}
)

// SecureValueErrorTranslationFiles represents TL type `secureValueErrorTranslationFiles#34636dd8`.
// Represents an issue with the translated version of a document. The error is considered
// resolved when a file with the document translation changes.
//
// See https://core.telegram.org/constructor/secureValueErrorTranslationFiles for reference.
type SecureValueErrorTranslationFiles struct {
	// One of secureValueTypePersonalDetails¹, secureValueTypePassport²,
	// secureValueTypeDriverLicense³, secureValueTypeIdentityCard⁴,
	// secureValueTypeInternalPassport⁵, secureValueTypeUtilityBill⁶,
	// secureValueTypeBankStatement⁷, secureValueTypeRentalAgreement⁸,
	// secureValueTypePassportRegistration⁹, secureValueTypeTemporaryRegistration¹⁰
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypePersonalDetails
	//  2) https://core.telegram.org/constructor/secureValueTypePassport
	//  3) https://core.telegram.org/constructor/secureValueTypeDriverLicense
	//  4) https://core.telegram.org/constructor/secureValueTypeIdentityCard
	//  5) https://core.telegram.org/constructor/secureValueTypeInternalPassport
	//  6) https://core.telegram.org/constructor/secureValueTypeUtilityBill
	//  7) https://core.telegram.org/constructor/secureValueTypeBankStatement
	//  8) https://core.telegram.org/constructor/secureValueTypeRentalAgreement
	//  9) https://core.telegram.org/constructor/secureValueTypePassportRegistration
	//  10) https://core.telegram.org/constructor/secureValueTypeTemporaryRegistration
	Type SecureValueTypeClass
	// Hash
	FileHash [][]byte
	// Error message
	Text string
}

// SecureValueErrorTranslationFilesTypeID is TL type id of SecureValueErrorTranslationFiles.
const SecureValueErrorTranslationFilesTypeID = 0x34636dd8

func (s *SecureValueErrorTranslationFiles) Zero() bool {
	if s == nil {
		return true
	}
	if !(s.Type == nil) {
		return false
	}
	if !(s.FileHash == nil) {
		return false
	}
	if !(s.Text == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (s *SecureValueErrorTranslationFiles) String() string {
	if s == nil {
		return "SecureValueErrorTranslationFiles(nil)"
	}
	type Alias SecureValueErrorTranslationFiles
	return fmt.Sprintf("SecureValueErrorTranslationFiles%+v", Alias(*s))
}

// FillFrom fills SecureValueErrorTranslationFiles from given interface.
func (s *SecureValueErrorTranslationFiles) FillFrom(from interface {
	GetType() (value SecureValueTypeClass)
	GetFileHash() (value [][]byte)
	GetText() (value string)
}) {
	s.Type = from.GetType()
	s.FileHash = from.GetFileHash()
	s.Text = from.GetText()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*SecureValueErrorTranslationFiles) TypeID() uint32 {
	return SecureValueErrorTranslationFilesTypeID
}

// TypeName returns name of type in TL schema.
func (*SecureValueErrorTranslationFiles) TypeName() string {
	return "secureValueErrorTranslationFiles"
}

// TypeInfo returns info about TL type.
func (s *SecureValueErrorTranslationFiles) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "secureValueErrorTranslationFiles",
		ID:   SecureValueErrorTranslationFilesTypeID,
	}
	if s == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Type",
			SchemaName: "type",
		},
		{
			Name:       "FileHash",
			SchemaName: "file_hash",
		},
		{
			Name:       "Text",
			SchemaName: "text",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (s *SecureValueErrorTranslationFiles) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorTranslationFiles#34636dd8 as nil")
	}
	b.PutID(SecureValueErrorTranslationFilesTypeID)
	return s.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (s *SecureValueErrorTranslationFiles) EncodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode secureValueErrorTranslationFiles#34636dd8 as nil")
	}
	if s.Type == nil {
		return fmt.Errorf("unable to encode secureValueErrorTranslationFiles#34636dd8: field type is nil")
	}
	if err := s.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode secureValueErrorTranslationFiles#34636dd8: field type: %w", err)
	}
	b.PutVectorHeader(len(s.FileHash))
	for _, v := range s.FileHash {
		b.PutBytes(v)
	}
	b.PutString(s.Text)
	return nil
}

// GetType returns value of Type field.
func (s *SecureValueErrorTranslationFiles) GetType() (value SecureValueTypeClass) {
	return s.Type
}

// GetFileHash returns value of FileHash field.
func (s *SecureValueErrorTranslationFiles) GetFileHash() (value [][]byte) {
	return s.FileHash
}

// GetText returns value of Text field.
func (s *SecureValueErrorTranslationFiles) GetText() (value string) {
	return s.Text
}

// Decode implements bin.Decoder.
func (s *SecureValueErrorTranslationFiles) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorTranslationFiles#34636dd8 to nil")
	}
	if err := b.ConsumeID(SecureValueErrorTranslationFilesTypeID); err != nil {
		return fmt.Errorf("unable to decode secureValueErrorTranslationFiles#34636dd8: %w", err)
	}
	return s.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (s *SecureValueErrorTranslationFiles) DecodeBare(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode secureValueErrorTranslationFiles#34636dd8 to nil")
	}
	{
		value, err := DecodeSecureValueType(b)
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorTranslationFiles#34636dd8: field type: %w", err)
		}
		s.Type = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorTranslationFiles#34636dd8: field file_hash: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode secureValueErrorTranslationFiles#34636dd8: field file_hash: %w", err)
			}
			s.FileHash = append(s.FileHash, value)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode secureValueErrorTranslationFiles#34636dd8: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// construct implements constructor of SecureValueErrorClass.
func (s SecureValueErrorTranslationFiles) construct() SecureValueErrorClass { return &s }

// Ensuring interfaces in compile-time for SecureValueErrorTranslationFiles.
var (
	_ bin.Encoder     = &SecureValueErrorTranslationFiles{}
	_ bin.Decoder     = &SecureValueErrorTranslationFiles{}
	_ bin.BareEncoder = &SecureValueErrorTranslationFiles{}
	_ bin.BareDecoder = &SecureValueErrorTranslationFiles{}

	_ SecureValueErrorClass = &SecureValueErrorTranslationFiles{}
)

// SecureValueErrorClass represents SecureValueError generic type.
//
// See https://core.telegram.org/type/SecureValueError for reference.
//
// Example:
//  g, err := tg.DecodeSecureValueError(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.SecureValueErrorData: // secureValueErrorData#e8a40bd9
//  case *tg.SecureValueErrorFrontSide: // secureValueErrorFrontSide#be3dfa
//  case *tg.SecureValueErrorReverseSide: // secureValueErrorReverseSide#868a2aa5
//  case *tg.SecureValueErrorSelfie: // secureValueErrorSelfie#e537ced6
//  case *tg.SecureValueErrorFile: // secureValueErrorFile#7a700873
//  case *tg.SecureValueErrorFiles: // secureValueErrorFiles#666220e9
//  case *tg.SecureValueError: // secureValueError#869d758f
//  case *tg.SecureValueErrorTranslationFile: // secureValueErrorTranslationFile#a1144770
//  case *tg.SecureValueErrorTranslationFiles: // secureValueErrorTranslationFiles#34636dd8
//  default: panic(v)
//  }
type SecureValueErrorClass interface {
	bin.Encoder
	bin.Decoder
	bin.BareEncoder
	bin.BareDecoder
	tdp.Object
	construct() SecureValueErrorClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeInfo returns TL type info.
	TypeInfo() tdp.Type
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool

	// The section of the user's Telegram Passport which has the error, one of
	// secureValueTypePersonalDetails¹, secureValueTypePassport²,
	// secureValueTypeDriverLicense³, secureValueTypeIdentityCard⁴,
	// secureValueTypeInternalPassport⁵, secureValueTypeAddress⁶
	//
	// Links:
	//  1) https://core.telegram.org/constructor/secureValueTypePersonalDetails
	//  2) https://core.telegram.org/constructor/secureValueTypePassport
	//  3) https://core.telegram.org/constructor/secureValueTypeDriverLicense
	//  4) https://core.telegram.org/constructor/secureValueTypeIdentityCard
	//  5) https://core.telegram.org/constructor/secureValueTypeInternalPassport
	//  6) https://core.telegram.org/constructor/secureValueTypeAddress
	GetType() (value SecureValueTypeClass)

	// Error message
	GetText() (value string)
}

// DecodeSecureValueError implements binary de-serialization for SecureValueErrorClass.
func DecodeSecureValueError(buf *bin.Buffer) (SecureValueErrorClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case SecureValueErrorDataTypeID:
		// Decoding secureValueErrorData#e8a40bd9.
		v := SecureValueErrorData{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorFrontSideTypeID:
		// Decoding secureValueErrorFrontSide#be3dfa.
		v := SecureValueErrorFrontSide{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorReverseSideTypeID:
		// Decoding secureValueErrorReverseSide#868a2aa5.
		v := SecureValueErrorReverseSide{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorSelfieTypeID:
		// Decoding secureValueErrorSelfie#e537ced6.
		v := SecureValueErrorSelfie{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorFileTypeID:
		// Decoding secureValueErrorFile#7a700873.
		v := SecureValueErrorFile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorFilesTypeID:
		// Decoding secureValueErrorFiles#666220e9.
		v := SecureValueErrorFiles{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorTypeID:
		// Decoding secureValueError#869d758f.
		v := SecureValueError{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorTranslationFileTypeID:
		// Decoding secureValueErrorTranslationFile#a1144770.
		v := SecureValueErrorTranslationFile{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	case SecureValueErrorTranslationFilesTypeID:
		// Decoding secureValueErrorTranslationFiles#34636dd8.
		v := SecureValueErrorTranslationFiles{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode SecureValueErrorClass: %w", bin.NewUnexpectedID(id))
	}
}

// SecureValueError boxes the SecureValueErrorClass providing a helper.
type SecureValueErrorBox struct {
	SecureValueError SecureValueErrorClass
}

// TypeInfo implements tdp.Object for SecureValueErrorBox.
func (b *SecureValueErrorBox) TypeInfo() tdp.Type {
	return b.SecureValueError.TypeInfo()
}

// Decode implements bin.Decoder for SecureValueErrorBox.
func (b *SecureValueErrorBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode SecureValueErrorBox to nil")
	}
	v, err := DecodeSecureValueError(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.SecureValueError = v
	return nil
}

// Encode implements bin.Encode for SecureValueErrorBox.
func (b *SecureValueErrorBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.SecureValueError == nil {
		return fmt.Errorf("unable to encode SecureValueErrorClass as nil")
	}
	return b.SecureValueError.Encode(buf)
}

// SecureValueErrorClassArray is adapter for slice of SecureValueErrorClass.
type SecureValueErrorClassArray []SecureValueErrorClass

// Sort sorts slice of SecureValueErrorClass.
func (s SecureValueErrorClassArray) Sort(less func(a, b SecureValueErrorClass) bool) SecureValueErrorClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorClass.
func (s SecureValueErrorClassArray) SortStable(less func(a, b SecureValueErrorClass) bool) SecureValueErrorClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorClass.
func (s SecureValueErrorClassArray) Retain(keep func(x SecureValueErrorClass) bool) SecureValueErrorClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorClassArray) First() (v SecureValueErrorClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorClassArray) Last() (v SecureValueErrorClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorClassArray) PopFirst() (v SecureValueErrorClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorClassArray) Pop() (v SecureValueErrorClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsSecureValueErrorData returns copy with only SecureValueErrorData constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorData() (to SecureValueErrorDataArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorData)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueErrorFrontSide returns copy with only SecureValueErrorFrontSide constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorFrontSide() (to SecureValueErrorFrontSideArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorFrontSide)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueErrorReverseSide returns copy with only SecureValueErrorReverseSide constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorReverseSide() (to SecureValueErrorReverseSideArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorReverseSide)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueErrorSelfie returns copy with only SecureValueErrorSelfie constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorSelfie() (to SecureValueErrorSelfieArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorSelfie)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueErrorFile returns copy with only SecureValueErrorFile constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorFile() (to SecureValueErrorFileArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorFile)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueErrorFiles returns copy with only SecureValueErrorFiles constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorFiles() (to SecureValueErrorFilesArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorFiles)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueError returns copy with only SecureValueError constructors.
func (s SecureValueErrorClassArray) AsSecureValueError() (to SecureValueErrorArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueError)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueErrorTranslationFile returns copy with only SecureValueErrorTranslationFile constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorTranslationFile() (to SecureValueErrorTranslationFileArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorTranslationFile)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsSecureValueErrorTranslationFiles returns copy with only SecureValueErrorTranslationFiles constructors.
func (s SecureValueErrorClassArray) AsSecureValueErrorTranslationFiles() (to SecureValueErrorTranslationFilesArray) {
	for _, elem := range s {
		value, ok := elem.(*SecureValueErrorTranslationFiles)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// SecureValueErrorDataArray is adapter for slice of SecureValueErrorData.
type SecureValueErrorDataArray []SecureValueErrorData

// Sort sorts slice of SecureValueErrorData.
func (s SecureValueErrorDataArray) Sort(less func(a, b SecureValueErrorData) bool) SecureValueErrorDataArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorData.
func (s SecureValueErrorDataArray) SortStable(less func(a, b SecureValueErrorData) bool) SecureValueErrorDataArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorData.
func (s SecureValueErrorDataArray) Retain(keep func(x SecureValueErrorData) bool) SecureValueErrorDataArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorDataArray) First() (v SecureValueErrorData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorDataArray) Last() (v SecureValueErrorData, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorDataArray) PopFirst() (v SecureValueErrorData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorData
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorDataArray) Pop() (v SecureValueErrorData, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorFrontSideArray is adapter for slice of SecureValueErrorFrontSide.
type SecureValueErrorFrontSideArray []SecureValueErrorFrontSide

// Sort sorts slice of SecureValueErrorFrontSide.
func (s SecureValueErrorFrontSideArray) Sort(less func(a, b SecureValueErrorFrontSide) bool) SecureValueErrorFrontSideArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorFrontSide.
func (s SecureValueErrorFrontSideArray) SortStable(less func(a, b SecureValueErrorFrontSide) bool) SecureValueErrorFrontSideArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorFrontSide.
func (s SecureValueErrorFrontSideArray) Retain(keep func(x SecureValueErrorFrontSide) bool) SecureValueErrorFrontSideArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorFrontSideArray) First() (v SecureValueErrorFrontSide, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorFrontSideArray) Last() (v SecureValueErrorFrontSide, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorFrontSideArray) PopFirst() (v SecureValueErrorFrontSide, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorFrontSide
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorFrontSideArray) Pop() (v SecureValueErrorFrontSide, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorReverseSideArray is adapter for slice of SecureValueErrorReverseSide.
type SecureValueErrorReverseSideArray []SecureValueErrorReverseSide

// Sort sorts slice of SecureValueErrorReverseSide.
func (s SecureValueErrorReverseSideArray) Sort(less func(a, b SecureValueErrorReverseSide) bool) SecureValueErrorReverseSideArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorReverseSide.
func (s SecureValueErrorReverseSideArray) SortStable(less func(a, b SecureValueErrorReverseSide) bool) SecureValueErrorReverseSideArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorReverseSide.
func (s SecureValueErrorReverseSideArray) Retain(keep func(x SecureValueErrorReverseSide) bool) SecureValueErrorReverseSideArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorReverseSideArray) First() (v SecureValueErrorReverseSide, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorReverseSideArray) Last() (v SecureValueErrorReverseSide, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorReverseSideArray) PopFirst() (v SecureValueErrorReverseSide, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorReverseSide
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorReverseSideArray) Pop() (v SecureValueErrorReverseSide, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorSelfieArray is adapter for slice of SecureValueErrorSelfie.
type SecureValueErrorSelfieArray []SecureValueErrorSelfie

// Sort sorts slice of SecureValueErrorSelfie.
func (s SecureValueErrorSelfieArray) Sort(less func(a, b SecureValueErrorSelfie) bool) SecureValueErrorSelfieArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorSelfie.
func (s SecureValueErrorSelfieArray) SortStable(less func(a, b SecureValueErrorSelfie) bool) SecureValueErrorSelfieArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorSelfie.
func (s SecureValueErrorSelfieArray) Retain(keep func(x SecureValueErrorSelfie) bool) SecureValueErrorSelfieArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorSelfieArray) First() (v SecureValueErrorSelfie, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorSelfieArray) Last() (v SecureValueErrorSelfie, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorSelfieArray) PopFirst() (v SecureValueErrorSelfie, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorSelfie
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorSelfieArray) Pop() (v SecureValueErrorSelfie, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorFileArray is adapter for slice of SecureValueErrorFile.
type SecureValueErrorFileArray []SecureValueErrorFile

// Sort sorts slice of SecureValueErrorFile.
func (s SecureValueErrorFileArray) Sort(less func(a, b SecureValueErrorFile) bool) SecureValueErrorFileArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorFile.
func (s SecureValueErrorFileArray) SortStable(less func(a, b SecureValueErrorFile) bool) SecureValueErrorFileArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorFile.
func (s SecureValueErrorFileArray) Retain(keep func(x SecureValueErrorFile) bool) SecureValueErrorFileArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorFileArray) First() (v SecureValueErrorFile, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorFileArray) Last() (v SecureValueErrorFile, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorFileArray) PopFirst() (v SecureValueErrorFile, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorFile
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorFileArray) Pop() (v SecureValueErrorFile, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorFilesArray is adapter for slice of SecureValueErrorFiles.
type SecureValueErrorFilesArray []SecureValueErrorFiles

// Sort sorts slice of SecureValueErrorFiles.
func (s SecureValueErrorFilesArray) Sort(less func(a, b SecureValueErrorFiles) bool) SecureValueErrorFilesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorFiles.
func (s SecureValueErrorFilesArray) SortStable(less func(a, b SecureValueErrorFiles) bool) SecureValueErrorFilesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorFiles.
func (s SecureValueErrorFilesArray) Retain(keep func(x SecureValueErrorFiles) bool) SecureValueErrorFilesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorFilesArray) First() (v SecureValueErrorFiles, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorFilesArray) Last() (v SecureValueErrorFiles, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorFilesArray) PopFirst() (v SecureValueErrorFiles, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorFiles
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorFilesArray) Pop() (v SecureValueErrorFiles, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorArray is adapter for slice of SecureValueError.
type SecureValueErrorArray []SecureValueError

// Sort sorts slice of SecureValueError.
func (s SecureValueErrorArray) Sort(less func(a, b SecureValueError) bool) SecureValueErrorArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueError.
func (s SecureValueErrorArray) SortStable(less func(a, b SecureValueError) bool) SecureValueErrorArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueError.
func (s SecureValueErrorArray) Retain(keep func(x SecureValueError) bool) SecureValueErrorArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorArray) First() (v SecureValueError, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorArray) Last() (v SecureValueError, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorArray) PopFirst() (v SecureValueError, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueError
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorArray) Pop() (v SecureValueError, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorTranslationFileArray is adapter for slice of SecureValueErrorTranslationFile.
type SecureValueErrorTranslationFileArray []SecureValueErrorTranslationFile

// Sort sorts slice of SecureValueErrorTranslationFile.
func (s SecureValueErrorTranslationFileArray) Sort(less func(a, b SecureValueErrorTranslationFile) bool) SecureValueErrorTranslationFileArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorTranslationFile.
func (s SecureValueErrorTranslationFileArray) SortStable(less func(a, b SecureValueErrorTranslationFile) bool) SecureValueErrorTranslationFileArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorTranslationFile.
func (s SecureValueErrorTranslationFileArray) Retain(keep func(x SecureValueErrorTranslationFile) bool) SecureValueErrorTranslationFileArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorTranslationFileArray) First() (v SecureValueErrorTranslationFile, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorTranslationFileArray) Last() (v SecureValueErrorTranslationFile, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorTranslationFileArray) PopFirst() (v SecureValueErrorTranslationFile, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorTranslationFile
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorTranslationFileArray) Pop() (v SecureValueErrorTranslationFile, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// SecureValueErrorTranslationFilesArray is adapter for slice of SecureValueErrorTranslationFiles.
type SecureValueErrorTranslationFilesArray []SecureValueErrorTranslationFiles

// Sort sorts slice of SecureValueErrorTranslationFiles.
func (s SecureValueErrorTranslationFilesArray) Sort(less func(a, b SecureValueErrorTranslationFiles) bool) SecureValueErrorTranslationFilesArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of SecureValueErrorTranslationFiles.
func (s SecureValueErrorTranslationFilesArray) SortStable(less func(a, b SecureValueErrorTranslationFiles) bool) SecureValueErrorTranslationFilesArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of SecureValueErrorTranslationFiles.
func (s SecureValueErrorTranslationFilesArray) Retain(keep func(x SecureValueErrorTranslationFiles) bool) SecureValueErrorTranslationFilesArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s SecureValueErrorTranslationFilesArray) First() (v SecureValueErrorTranslationFiles, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s SecureValueErrorTranslationFilesArray) Last() (v SecureValueErrorTranslationFiles, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *SecureValueErrorTranslationFilesArray) PopFirst() (v SecureValueErrorTranslationFiles, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero SecureValueErrorTranslationFiles
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *SecureValueErrorTranslationFilesArray) Pop() (v SecureValueErrorTranslationFiles, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
